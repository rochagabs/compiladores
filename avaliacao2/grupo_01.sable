Package caju;

Helpers
 digito = ['0' .. '9'];
 espaco = ' ';
 rc = 13;
 nl = 10;
 quebra_linha = [rc + nl];
 letra_minusc = ['a'..'z'];
 letra_maiusc = ['A'..'Z'];
 tudo = [0..0xffff];
 tudo_sem_nl = [tudo - quebra_linha];
 string_input = [tudo - ['''+'"']];
 identificadorhelper = (letra_maiusc | letra_minusc)(letra_maiusc | letra_minusc | digito | '_')*;
 comentario = [tudo - '{'];
 digitos = digito+;
 numero_real = '-'?digitos','digitos;
 numero_inteiro = '-'?digitos;
 
Tokens 
 numero = (numero_real | numero_inteiro);
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 igual = '=';
 maior = '>';
 menor = '<';
 maior_igual = '>=';
 menor_igual = '<=';
 inicio = 'inicio';
 fim = 'fim';
 booleano_palavra = 'booleano';
 numero_palavra = 'numero';
 caractere_palavra = 'caractere';
 vetor_palavra = 'vetor';
 palavra_vazio = 'vazio';
 string = '"'string_input*'"';
 par_esq = '(';
 par_dir = ')';
 colchete_esq = '[';
 colchete_dir = ']';
 ponto = '.';
 virgula = ',';
 barra = '|';
 ponto_e_virgula = ';';
 iniciador = '->';
 atribuicao = ':=';
 dois_pontos = ':';
 booleano = 'verdadeiro' | 'falso';
 enquanto = 'enquanto';
 para_cada = 'para cada';
 para = 'para';
 retorne = 'retorne';
 se = 'se';
 senao = 'senao';
 nao = 'nao';
 e = 'e';
 ou = 'ou';
 vazio = (espaco | rc | nl)+;
 caractere = '''(string_input | '\'letra_minusc)''';
 identificador = identificadorhelper;
 comentario_linha = '#'tudo_sem_nl*;
 comentario_bloco = '{'comentario*'}';


Ignored Tokens
 comentario_linha,
 comentario_bloco,
 vazio;

Productions
 
 //Produção inicial
 programa {-> a_programa} =
 		{programa} dec_variavel* dec_funcao* {-> New a_programa.a_programa([dec_variavel.a_dec_variavel], [dec_funcao.a_dec_funcao])};

 //Declaração variável
 dec_variavel {-> a_dec_variavel} = {dec_variavel} tipo lista_nomes ponto {-> New a_dec_variavel.dec_variavel(tipo.a_tipo, lista_nomes.a_lista_nomes)};
 
 //Define os identificadores das variáveis
 lista_nomes {-> a_lista_nomes} = 
 	 {identificadores} identificador virgula lista_nomes {-> New a_lista_nomes.identificadores(identificador, lista_nomes.a_lista_nomes)}
 	|{identificador} identificador {-> New a_lista_nomes.identificador(identificador)};
 
 //Tipo das variáveis, que pode ser um tipo primitivo ou array
 tipo {-> a_tipo} =
 	 {tipo_base} tipo_base {-> New a_tipo.tipo_base(tipo_base.a_tipo_base)} //falta mudar a parte do exp
 	|{vetor} vetor_palavra tipo_base colchete_esq exp colchete_dir vetor_estrela*	{-> New a_tipo.vetor(tipo_base.a_tipo_base,exp.a_exp, [vetor_estrela.a_vetor_estrela])};
 	
 vetor_estrela {->a_vetor_estrela} =  //mudar parte do exp
 		{expressao} colchete_esq exp colchete_dir {->New a_vetor_estrela.expressao(exp.a_exp)};
 
 tipo_base {-> a_tipo_base} = 
 	 {booleano_palavra} booleano_palavra {-> New a_tipo_base.booleano_palavra(booleano_palavra)}
	|{caractere_palavra} caractere_palavra {-> New a_tipo_base.caractere_palavra(caractere_palavra)}
	|{numero_palavra} numero_palavra {-> New a_tipo_base.numero_palavra(numero_palavra)};
	
 dec_funcao {-> a_dec_funcao} = 
 	{dec_funcao} iniciador? tipo_retorno identificador par_esq parametros par_dir bloco {-> New a_dec_funcao.dec_funcao(tipo_retorno.a_tipo_retorno ,identificador, parametros.a_parametros, bloco.a_bloco)};
 
 tipo_retorno {-> a_tipo_retorno} = 
 	{tipo} tipo {-> New a_tipo_retorno.tipo(tipo.a_tipo)}
   |{vazio} palavra_vazio {-> New a_tipo_retorno.vazio(palavra_vazio)};
 
 parametros {-> a_parametros} =
 	 {parametros} parametro parametro_estrela* {-> New a_parametros.parametros(parametro.a_parametro, [parametro_estrela.a_parametro_estrela])}
 	|{nada} {-> New a_parametros.nada()};
 	
 parametro {-> a_parametro} = {parametro} tipo identificador {-> New a_parametro.parametro(tipo.a_tipo, identificador)};
 
 parametro_estrela {-> a_parametro_estrela} = {parametro_estrela} barra parametro {-> New a_parametro_estrela.parametro_estrela(parametro.a_parametro)};
 
 bloco {-> a_bloco} = {bloco} inicio dec_variavel* comando* fim {-> New a_bloco.bloco([dec_variavel.a_dec_variavel], [comando.a_comando])};
 
 atrib {-> a_atrib} = {atrib} p_var atribuicao exp {-> New a_atrib.atrib(p_var.a_var, exp.a_exp)};
 
 lista_atrib {-> a_lista_atrib} = {lista_atrib} atrib atrib_estrela* {-> New a_lista_atrib.lista_atrib(atrib.a_atrib, [atrib_estrela.a_atrib_estrela])};

 atrib_estrela {-> a_atrib_estrela} = {atrib_estrela} virgula atrib {-> New a_atrib_estrela.atrib_estrela(atrib.a_atrib)};
  
 comando {-> a_comando} =
 	 {comando_casado} comando_casado {-> New a_comando.comando_casado(comando_casado.a_comando_casado)}
 	|{comando_nao_casado} comando_nao_casado {-> New a_comando.comando_nao_casado(comando_nao_casado.a_comando_nao_casado)};
 
 comando_casado {-> a_comando_casado} = 
 	{se} se par_esq exp par_dir [esq]:comando_casado senao [dir]:comando_casado {-> New a_comando_casado.se(exp.a_exp, esq.a_comando_casado, dir.a_comando_casado)}
    |{outra} outra {-> New a_comando_casado.outra(outra.a_outra)}; 
 
 comando_nao_casado {-> a_comando_nao_casado} = 
 	{se} se par_esq exp par_dir comando {-> New a_comando_nao_casado.se(exp.a_exp, comando.a_comando)}
   |{se_senao} se par_esq exp par_dir comando_casado senao comando_nao_casado {-> New a_comando_nao_casado.se_senao(exp.a_exp, comando_casado.a_comando_casado, comando_nao_casado.a_comando_nao_casado)};
   
 
 outra {-> a_outra} = 
 	 {enquanto} enquanto par_esq exp par_dir comando_casado {-> New a_outra.enquanto(exp.a_exp, comando_casado.a_comando_casado)}
 	|{para} para par_esq [atrib_esq]:lista_atrib [esq]:ponto_e_virgula exp [dir]:ponto_e_virgula [atrib_dir]:lista_atrib par_dir comando_casado {-> New a_outra.para(atrib_esq.a_lista_atrib, exp.a_exp, atrib_dir.a_lista_atrib, comando_casado.a_comando_casado)}
 	|{para_cada} para_cada par_esq tipo [esq]:identificador dois_pontos [dir]:identificador par_dir comando_casado {-> New a_outra.para_cada(tipo.a_tipo, comando_casado.a_comando_casado)}
 	|{atrib_ponto} atrib ponto {-> New a_outra.atrib_ponto(atrib.a_atrib)}
 	|{retorne} retorne exp? ponto {-> New a_outra.retorne(exp.a_exp)}
 	|{bloco} bloco {-> New a_outra.bloco(bloco.a_bloco)}
 	|{chamada} chamada ponto {-> New a_outra.chamada(chamada.a_chamada)};
 
 p_var {-> a_var} = 
 	identificador {-> New a_var.identificador(identificador)}
 	|{var} p_var colchete_esq exp colchete_dir {-> New a_var.var(p_var.a_var, exp.a_exp)};
 
 exp {-> a_exp} =
 	{ou} [esq]:exp ou [dir]:nivel_um {-> New a_exp.ou(esq.a_exp, dir.a_exp)}
   |{nivel_um} nivel_um {-> nivel_um.a_exp};
 
 //prefixo prece significa "precedência" e quanto maior o nível maior a precedência
 
 nivel_um {-> a_exp} = 
 	 {e} [esq]:nivel_um e [dir]:nivel_dois {-> New a_exp.e(esq.a_exp, dir.a_exp)}
 	|{nivel_dois} nivel_dois {-> nivel_dois.a_exp};
 
 nivel_dois {-> a_exp} = 
 	 {igual} [esq]:nivel_dois igual [dir]:nivel_tres {-> New a_exp.igual(esq.a_exp, dir.a_exp)}
 	|{nivel_tres} nivel_tres {-> nivel_tres.a_exp};
 
 nivel_tres {-> a_exp} = 
 	 {menor} [esq]:nivel_tres menor [dir]:nivel_quatro {-> New a_exp.menor(esq.a_exp, dir.a_exp)}
 	|{maior} [esq]:nivel_tres maior [dir]:nivel_quatro {-> New a_exp.maior(esq.a_exp, dir.a_exp)}
 	|{menor_igual} [esq]:nivel_tres menor_igual [dir]:nivel_quatro {-> New a_exp.menor_igual(esq.a_exp, dir.a_exp)}
 	|{maior_igual} [esq]:nivel_tres maior_igual [dir]:nivel_quatro {-> New a_exp.maior_igual(esq.a_exp, dir.a_exp)}
 	|{nivel_quatro} nivel_quatro {-> nivel_quatro.a_exp};
 
 nivel_quatro {-> a_exp} = 
 	 {soma} [esq]:nivel_quatro soma [dir]:nivel_cinco {-> New a_exp.soma(esq.a_exp, dir.a_exp)}
 	|{menos} [esq]:nivel_quatro menos [dir]:nivel_cinco {-> New a_exp.menos(esq.a_exp, dir.a_exp)}
 	|{nivel_cinco} nivel_cinco {-> nivel_cinco.a_exp};
 
 nivel_cinco {-> a_exp} = 
 	 {mult} [esq]:nivel_cinco mult [dir]:nivel_seis {-> New a_exp.mult(esq.a_exp, dir.a_exp)}
 	|{div} [esq]:nivel_cinco div [dir]:nivel_seis {-> New a_exp.div(esq.a_exp, dir.a_exp)}
 	|{nivel_seis} nivel_seis {-> nivel_seis.a_exp};
 
 nivel_seis {-> a_exp} = 
 	 {nao} nao [dir]:nivel_seis {-> New a_exp.nao(dir.a_exp)}
 	|{nivel_sete} nivel_sete {-> nivel_sete.a_exp};
 
 nivel_sete {-> a_exp} = 
 	 {par} par_esq exp par_dir {-> New a_exp.par(exp.a_exp)}
 	|{var} p_var {-> New a_exp.var(p_var.a_var)}
 	|{numero} numero {-> New a_exp.numero(numero)}
 	|{caractere} caractere {-> New a_exp.caractere(caractere)}
 	|{string} string {-> New a_exp.string(string)}
 	|{booleano} booleano {-> New a_exp.booleano(booleano)}
 	|{chamada} chamada {-> New a_exp.chamada(chamada.a_chamada)};
 
 chamada {-> a_chamada} = 
 	 {chamada} identificador par_esq lista_exp par_dir {-> New a_chamada.chamada(identificador, lista_exp.a_lista_exp)};
 
 lista_exp {-> a_lista_exp} = 
 	{nada} {-> New a_lista_exp.nada()}
 	|{exp} exp ou_exp_estrela* {-> New a_lista_exp.exp(exp.a_exp, [ou_exp_estrela.a_ou_exp_estrela])};
 	
 ou_exp_estrela {-> a_ou_exp_estrela} = {ou_exp_estrela} barra exp {-> New a_ou_exp_estrela.ou_exp_estrela(exp.a_exp)}; 
 
 
 Abstract Syntax Tree
 
 a_programa = {a_programa} a_dec_variavel* a_dec_funcao*;
 
 a_dec_variavel = {dec_variavel} a_tipo a_lista_nomes;
 
 a_lista_nomes = {identificadores} identificador a_lista_nomes
 				|{identificador} identificador;
 				
 a_tipo = {tipo_base} a_tipo_base
 		  |{vetor} a_tipo_base a_exp a_vetor_estrela*;
 
 a_vetor_estrela = {expressao} a_exp ;
 		  
 a_tipo_base = 
 	 {booleano_palavra} booleano_palavra
	|{caractere_palavra} caractere_palavra
	|{numero_palavra} numero_palavra;
	
 a_dec_funcao = {dec_funcao} a_tipo_retorno identificador a_parametros a_bloco;
 
 a_tipo_retorno = {tipo} a_tipo | {vazio} palavra_vazio;
 
 a_parametros = 
 	 {parametros} a_parametro a_parametro_estrela*
 	|{nada};
 
 a_parametro = {parametro} a_tipo identificador;
 
 a_parametro_estrela = {parametro_estrela} a_parametro;
 				
 a_bloco = {bloco} a_dec_variavel* a_comando*;
 
 a_atrib = {atrib} a_var a_exp;
 
 a_lista_atrib = {lista_atrib} a_atrib a_atrib_estrela*;

 a_atrib_estrela = {atrib_estrela} a_atrib;
 
 a_comando_casado  = 
 	 {se} a_exp [esq]:a_comando_casado [dir]:a_comando_casado
    |{outra} a_outra; 
    
 a_comando_nao_casado = 
 	 {se} a_exp a_comando
    |{se_senao} a_exp a_comando_casado a_comando_nao_casado;
       
 a_comando = {comando_casado} a_comando_casado
 			|{comando_nao_casado} a_comando_nao_casado;
 			
 a_outra = 
 	 {enquanto}  a_exp a_comando_casado
 	|{para} [atrib_esq]:a_lista_atrib a_exp [atrib_dir]:a_lista_atrib a_comando_casado
 	|{para_cada} a_tipo a_comando_casado
 	|{atrib_ponto} a_atrib 
 	|{retorne} a_exp? 
 	|{bloco} a_bloco
 	|{chamada} a_chamada ;
 			
 a_var = {identificador} identificador
 		|{var} a_var a_exp;
 		
 a_exp = 
 	 {soma} [esq]:a_exp [dir]:a_exp
 	|{menos} [esq]:a_exp [dir]:a_exp
 	|{mult} [esq]:a_exp [dir]:a_exp
 	|{div} [esq]:a_exp [dir]:a_exp
 	|{igual} [esq]:a_exp [dir]:a_exp
 	|{menor} [esq]:a_exp [dir]:a_exp
 	|{maior} [esq]:a_exp [dir]:a_exp
 	|{menor_igual} [esq]:a_exp [dir]:a_exp
 	|{maior_igual} [esq]:a_exp [dir]:a_exp
 	|{e} [esq]:a_exp [dir]:a_exp
 	|{ou} [esq]:a_exp [dir]:a_exp
 	|{nao} [dir]:a_exp
 	|{chamada} a_chamada
 	|{par} a_exp
 	|{var} a_var
 	|{numero} numero
 	|{caractere} caractere
 	|{booleano} booleano
 	|{string} string;
 	
 a_chamada = {chamada} identificador a_lista_exp;
 
 a_lista_exp = {nada} 
 	|{exp} a_exp a_ou_exp_estrela*;
 	
 a_ou_exp_estrela = {ou_exp_estrela} a_exp; 
 
