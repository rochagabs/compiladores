Package caju;

Helpers
 digito = ['0' .. '9'];
 espaco = ' ';
 rc = 13;
 nl = 10;
 quebra_linha = [rc + nl];
 letra_minusc = ['a'..'z'];
 letra_maiusc = ['A'..'Z'];
 tudo = [0..0xffff];
 tudo_sem_nl = [tudo - quebra_linha];
 string_input = [tudo - ['''+'"']];
 identificadorhelper = (letra_maiusc | letra_minusc)(letra_maiusc | letra_minusc | digito | '_')*;
 comentario = [tudo - '{'];
 digitos = digito+;
 numero_real = '-'?digitos','digitos;
 numero_inteiro = '-'?digitos;
 
Tokens 
 numero = (numero_real | numero_inteiro);
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 igual = '=';
 maior = '>';
 menor = '<';
 maior_igual = '>=';
 menor_igual = '<=';
 inicio = 'inicio';
 fim = 'fim';
 booleano_palavra = 'booleano';
 numero_palavra = 'numero';
 caractere_palavra = 'caractere';
 vetor_palavra = 'vetor';
 palavra_vazio = 'vazio';
 string = '"'string_input*'"';
 par_esq = '(';
 par_dir = ')';
 colchete_esq = '[';
 colchete_dir = ']';
 ponto = '.';
 virgula = ',';
 barra = '|';
 ponto_e_virgula = ';';
 iniciador = '->';
 atribuicao = ':=';
 dois_pontos = ':';
 booleano = 'verdadeiro' | 'falso';
 enquanto = 'enquanto';
 para_cada = 'para cada';
 para = 'para';
 retorne = 'retorne';
 se = 'se';
 senao = 'senao';
 nao = 'nao';
 e = 'e';
 ou = 'ou';
 vazio = (espaco | rc | nl)+;
 caractere = '''(string_input | '\'letra_minusc)''';
 identificador = identificadorhelper;
 comentario_linha = '#'tudo_sem_nl*;
 comentario_bloco = '{'comentario*'}';


Ignored Tokens
 comentario_linha,
 comentario_bloco,
 vazio;

Productions
 
 //Produção inicial
 programa {-> a_programa} =
 		{programa} dec_variavel* dec_funcao* {-> New a_programa.a_programa(dec_variavel.a_dec_variavel, dec_funcao.a_dec_funcao)};

 //Declaração variável
 dec_variavel {-> a_dec_variavel} = {declaracao} tipo lista_nomes ponto {-> New a_declaracao.declaracao(tipo.a_tipo, lista_nomes.a_lista_nomes)};
 
 //Define os identificadores das variáveis
 lista_nomes {-> a_lista_nomes} = 
 	 {identificadores} identificador virgula lista_nomes {-> New a_lista_nomes.identificadores(identificador, lista_nomes.a_lista_nomes)}
 	|{identificador} identificador;
 
 //Tipo das variáveis, que pode ser um tipo primitivo ou array
 tipo {-> a_tipo} =
 	 {tipo_base} tipo_base {-> New a_tipo.tipo_base(tipo_base.a_tipo_base)} //falta mudar a parte do exp
 	|{vetor} vetor_palavra tipo_base colchete_esq exp colchete_dir vetor_estrela*	{-> New a_tipo.vetor(tipo_base.a_tipo_base, exp0.expr, [vetor_estrela.a_vetor_estrela])};
 	
 
 vetor_estrela {->a_vetor_estrela} =  //mudar parte do exp
 		{expressao} colchete_esq exp colchete_dir {->New a_vetor_estrela.expressao(exp0.exp)};
 
 tipo_base {-> a_tipo_base} = 
 	 {booleano_palavra} booleano_palavra {-> New a_tipo_base.booleano_palavra(booleano_palavra)}
	|{caractere_palavra} caractere_palavra {-> New a_tipo_base.caractere_palavra(caractere_palavra)}
	|{numero_palavra} numero_palavra {-> New a_tipo_base.numero_palavra(numero_palavra)};
	

 dec_funcao = iniciador? tipo_retorno identificador par_esq parametros par_dir bloco;
 
 tipo_retorno = {tipo} tipo | {vazio} palavra_vazio;
 
 parametros =
 	{nada}
 	|{varios_parametros} parametro parametro_estrela*; 
 
 parametro = tipo identificador;
 
 parametro_estrela = barra parametro;
 
 bloco {-> a_bloco} = inicio dec_variavel* comando* fim {-> New a_bloco.bloco([dec_variavel.a_dec_variavel], [comando.a_comando])};
 
 atrib = p_var atribuicao exp;
 
 lista_atrib = atrib atrib_estrela*;

 atrib_estrela = virgula atrib;
  
 comando {-> a_comando} =
 	 {comando_casado} comando_casado {-> New a_comando.comando_casado(comando_casado.a_comando_casado)}
 	|{comando_nao_casado} comando_nao_casado {-> New a_comando.comando_nao_casado(comando_nao_casado.a_comando_nao_casado)};
 
 
 comando_casado {-> a_comando_casado} = 
 	{se} se par_esq exp par_dir [esq]:comando_casado senao [dir]:comando_casado
    |{outra} outra; 
  
 
 comando_nao_casado = 
 	{se} se par_esq exp par_dir comando
       |{se_senao} se par_esq exp par_dir comando_casado senao comando_nao_casado;
   
 
 outra = 
 	 {enquanto} enquanto par_esq exp par_dir comando_casado
 	|{para} para par_esq [atrib_esq]:lista_atrib [esq]:ponto_e_virgula exp [dir]:ponto_e_virgula [atrib_dir]:lista_atrib par_dir comando_casado
 	|{para_cada} para_cada par_esq tipo [esq]:identificador dois_pontos [dir]:identificador par_dir comando_casado
 	|{atrib_ponto} atrib ponto
 	|{retorne} retorne exp? ponto
 	|{bloco} bloco
 	|{chamada} chamada ponto;
 
 p_var {-> a_var} = 
 	identificador {-> New a_var.identificador(identificador)}
 	|{var} p_var colchete_esq exp colchete_dir;
 
 exp {-> a_exp} =
 	{ou} [esq]:exp ou [dir]:nivel_um {-> New a_exp.ou(esq.a_exp, dir.a_exp)}
   |{nivel_um} nivel_um {-> nivel_um.a_exp};
 
 //prefixo prece significa "precedência" e quanto maior o nível maior a precedência
 
 nivel_um {-> a_exp} = 
 	 {e} [esq]:nivel_um e [dir]:nivel_dois {-> New a_exp.e(esq.a_exp, dir.a_exp)}
 	|{nivel_dois} nivel_dois {-> nivel_dois.a_exp};
 
 nivel_dois {-> a_exp} = 
 	 {igual} [esq]:nivel_dois igual [dir]:nivel_tres {-> New a_exp.igual(esq.a_exp, dir.a_exp)}
 	|{nivel_tres} nivel_tres {-> nivel_tres.a_exp};
 
 nivel_tres {-> a_exp} = 
 	 {menor} [esq]:nivel_tres menor [dir]:nivel_quatro {-> New a_exp.menor(esq.a_exp, dir.a_exp)}
 	|{maior} [esq]:nivel_tres maior [dir]:nivel_quatro {-> New a_exp.maior(esq.a_exp, dir.a_exp)}
 	|{menor_igual} [esq]:nivel_tres menor_igual [dir]:nivel_quatro {-> New a_exp.menor_igual(esq.a_exp, dir.a_exp)}
 	|{maior_igual} [esq]:nivel_tres maior_igual [dir]:nivel_quatro {-> New a_exp.maior_igual(esq.a_exp, dir.a_exp)}
 	|{nivel_quatro} nivel_quatro {-> nivel_quatro.a_exp};
 
 nivel_quatro {-> a_exp} = 
 	 {soma} [esq]:nivel_quatro soma [dir]:nivel_cinco {-> New a_exp.soma(esq.a_exp, dir.a_exp)}
 	|{menos} [esq]:nivel_quatro menos [dir]:nivel_cinco {-> New a_exp.menos(esq.a_exp, dir.a_exp)}
 	|{nivel_cinco} nivel_cinco {-> nivel_cinco.a_exp};
 
 nivel_cinco {-> a_exp} = 
 	 {mult} [esq]:nivel_cinco mult [dir]:nivel_seis {-> New a_exp.mult(esq.a_exp, dir.a_exp)}
 	|{div} [esq]:nivel_cinco div [dir]:nivel_seis {-> New a_exp.div(esq.a_exp, dir.a_exp)}
 	|{nivel_seis} nivel_seis {-> nivel_seis.a_exp};
 
 nivel_seis {-> a_exp} = 
 	 {nao} nao [dir]:nivel_seis {-> New a_exp.nao(dir.a_exp)}
 	|{nivel_sete} nivel_sete {-> nivel_sete.a_exp};
 
 nivel_sete {-> a_exp} = 
 	 {par_exp} par_esq exp par_dir {-> New a_exp.par_exp(exp.a_exp)}
 	|{var} p_var {-> New a_exp.p_var(p_var)}
 	|{numero} numero {-> New a_exp.numero(numero)}
 	|{caractere} caractere {-> New a_exp.caractere(caractere)}
 	|{string} string {-> New a_exp.string(string)}
 	|{booleano} booleano {-> New a_exp.booleano(booleano)}
 	|{chamada} chamada {-> New a_exp.chamada(chamada.a_chamada)};
 
 chamada = identificador par_esq lista_exp par_dir;
 
 lista_exp = 
 	{nada}
 	|{exp} exp ou_exp_estrela*;
 	
 ou_exp_estrela = barra exp; 
 
 
 Abstract Syntax Tree
 
 a_programa = {ar_programa} a_dec_variavel* a_dec_funcao*;
 
 a_dec_variavel = {ar_declaracoes} a_tipo a_lista_nomes;
 
 a_lista_nomes = {identificadores} identificador a_lista_nomes
 				|{identificador} identificador;
 				
 a_tipo = {tipo_base} a_tipo_base
 		  |{vetor} vetor_palavra a_tipo_base a_vetor_estrela*;
 
 a_vetor_estrela = colchete_esq a_exp colchete_dir;
 		  
 a_tipo_base = 
 	 {booleano} booleano_palavra
	|{caractere} caractere_palavra
	|{numero} numero_palavra;
	
 a_dec_funcao = iniciador? a_tipo_retorno identificador a_parametros a_bloco;
 
 a_tipo_retorno = {tipo} a_tipo | {vazio} palavra_vazio;
 
 a_parametros = {nada}
 		|{varios_parametros} a_parametro a_parametro_estrela*;
 
 a_parametro = a_tipo identificador;
 
 a_parametro_estrela = barra a_parametro;
 				
 a_bloco = a_dec_variavel* a_comando*;
 
 a_atrib = a_var atribuicao a_exp;
 
 a_lista_atrib = a_atrib a_atrib_estrela*;

 a_atrib_estrela = virgula a_atrib;
 
 a_comando_casado  = 
 	 {se} a_exp [esq]:a_comando_casado [dir]:a_comando_casado
    |{outra} a_outra; 
    
 a_comando_nao_casado = 
 	 {se} a_exp a_comando
    |{se_senao} a_exp a_comando_casado a_comando_nao_casado;
       
 a_comando = {comando_casado} a_comando_casado
 			|{comando_nao_casado} a_comando_nao_casado;
 			
 a_outra = 
 	 {enquanto} enquanto par_esq a_exp par_dir a_comando_casado
 	|{para} para par_esq [atrib_esq]:a_lista_atrib [esq]:ponto_e_virgula a_exp [dir]:ponto_e_virgula [atrib_dir]:a_lista_atrib par_dir a_comando_casado
 	|{para_cada} para_cada par_esq a_tipo [esq]:identificador dois_pontos [dir]:identificador par_dir a_comando_casado
 	|{atrib_ponto} a_atrib ponto
 	|{retorne} retorne a_exp? ponto
 	|{bloco} a_bloco
 	|{chamada} a_chamada ponto;
 			
 a_var = {identificador} identificador
 		|{var} a_var a_exp;
 		
 a_exp = 
 	 {a_soma} [esq]:a_exp [dir]:a_exp
 	|{a_menos} [esq]:a_exp [dir]:a_exp
 	|{a_mult} [esq]:a_exp [dir]:a_exp
 	|{a_div} [esq]:a_exp [dir]:a_exp
 	|{a_igual} [esq]:a_exp [dir]:a_exp
 	|{a_menor} [esq]:a_exp [dir]:a_exp
 	|{a_maior} [esq]:a_exp [dir]:a_exp
 	|{a_menor_igual} [esq]:a_exp [dir]:a_exp
 	|{a_maior_igual} [esq]:a_exp [dir]:a_exp
 	|{a_e} [esq]:a_exp [dir]:a_exp
 	|{a_ou} [esq]:a_exp [dir]:a_exp
 	|{a_nao} [dir]:a_exp
 	|{a_chamada} a_chamada
 	|{a_par} a_exp
 	|{a_var} a_var
 	|{a_numero} numero
 	|{a_caractere} caractere
 	|{a_booleano} booleano
 	|{a_string} string;
 
 a_chamada = identificador a_lista_exp;
 
 a_lista_exp = {nada}
 	|{exp} a_exp a_ou_exp_estrela*;
 	
 a_ou_exp_estrela = barra a_exp; 
 
