Package caju;

Helpers
 digito = ['0' .. '9'];
 espaco = ' ';
 rc = 13;
 nl = 10;
 quebra_linha = [rc + nl];
 letra_minusc = ['a'..'z'];
 letra_maiusc = ['A'..'Z'];
 tudo = [0..0xffff];
 tudo_sem_nl = [tudo - quebra_linha];
 string_input = [tudo - ['''+'"']];
 identificadorhelper = (letra_maiusc | letra_minusc)(letra_maiusc | letra_minusc | digito | '_')*;
 comentario = [tudo - '{'];
 digitos = digito+;
 numero_real = '-'?digitos','digitos;
 numero_inteiro = '-'?digitos;
 
Tokens 
 numero = (numero_real | numero_inteiro);
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 igual = '=';
 maior = '>';
 menor = '<';
 maior_igual = '>=';
 menor_igual = '<=';
 inicio = 'inicio';
 fim = 'fim';
 booleano_palavra = 'booleano';
 numero_palavra = 'numero';
 caractere_palavra = 'caractere';
 vetor_palavra = 'vetor';
 palavra_vazio = 'vazio';
 string = '"'string_input*'"';
 par_esq = '(';
 par_dir = ')';
 colchete_esq = '[';
 colchete_dir = ']';
 ponto = '.';
 virgula = ',';
 barra = '|';
 ponto_e_virgula = ';';
 iniciador = '->';
 atribuicao = ':=';
 dois_pontos = ':';
 booleano = 'verdadeiro' | 'falso';
 enquanto = 'enquanto';
 para_cada = 'para cada';
 para = 'para';
 retorne = 'retorne';
 se = 'se';
 senao = 'senao';
 nao = 'nao';
 e = 'e';
 ou = 'ou';
 vazio = (espaco | rc | nl)+;
 caractere = '''(string_input | '\'letra_minusc)''';
 identificador = identificadorhelper;
 comentario_linha = '#'tudo_sem_nl*;
 comentario_bloco = '{'comentario*'}';


Ignored Tokens
 comentario_linha,
 comentario_bloco,
 vazio;

Productions
 
 //Produção inicial
 programa {-> a_programa} =
 		{programa} dec_variavel* dec_funcao* {-> New a_programa.a_programa(a_dec_variavel, a_dec_funcao)};

 //Declaração variável
 dec_variavel = tipo lista_nomes ponto;
 
 //Define os identificadores das variáveis
 lista_nomes = 
 	 {identificadores} identificador virgula lista_nomes
 	|{identificador} identificador;
 
 //Tipo das variáveis, que pode ser um tipo primitivo ou array
 tipo {-> a_tipo} =
 	 {tipo_base} tipo_base {-> New a_tipo.tipo_base(tipo_base.a_tipo_base)} //falta mudar a parte do exp
 	|{vetor} vetor_palavra tipo_base colchete_esq exp colchete_dir vetor_estrela*	{-> New a_tipo.vetor(tipo_base.a_tipo_base, exp0.expr, [vetor_estrela.a_vetor_estrela])};
 	
 
 vetor_estrela {->a_vetor_estrela} =  //mudar parte do exp
 		{expressao} colchete_esq exp colchete_dir {->New a_vetor_estrela.expressao(exp0.exp)};
 
 tipo_base {-> a_tipo_base} = 
 	 {booleano_palavra} booleano_palavra {-> New a_tipo_base.booleano_palavra(booleano_palavra)}
	|{caractere_palavra} caractere_palavra {-> New a_tipo_base.caractere_palavra(caractere_palavra)}
	|{numero_palavra} numero_palavra {-> New a_tipo_base.numero_palavra(numero_palavra)};
	

 dec_funcao = iniciador? tipo_retorno identificador par_esq parametros par_dir bloco;
 
 tipo_retorno = {tipo} tipo | {vazio} palavra_vazio;
 
 parametros =
 	{nada}
 	|{varios_parametros} parametro parametro_estrela*; 
 
 parametro = tipo identificador;
 
 parametro_estrela = barra parametro;
 
 bloco {-> a_bloco} = inicio dec_variavel* comando* fim {-> New a_bloco.bloco([dec_variavel.a_dec_variavel], [comando.a_comando])};
 
 atrib = p_var atribuicao exp;
 
 lista_atrib = atrib atrib_estrela*;

 atrib_estrela = virgula atrib;
  
 comando {-> a_comando} =
 	 {comando_casado} comando_casado {-> New a_comando.comando_casado(comando_casado.a_comando_casado)}
 	|{comando_nao_casado} comando_nao_casado {-> New a_comando.comando_nao_casado(comando_nao_casado.a_comando_nao_casado)};
 
 
 comando_casado {-> a_comando_casado} = 
 	{se} se par_esq exp par_dir [esq]:comando_casado senao [dir]:comando_casado
    |{outra} outra; 
  
 
 comando_nao_casado = 
 	{se} se par_esq exp par_dir comando
       |{se_senao} se par_esq exp par_dir comando_casado senao comando_nao_casado;
   
 
 outra = 
 	 {enquanto} enquanto par_esq exp par_dir comando_casado
 	|{para} para par_esq [atrib_esq]:lista_atrib [esq]:ponto_e_virgula exp [dir]:ponto_e_virgula [atrib_dir]:lista_atrib par_dir comando_casado
 	|{para_cada} para_cada par_esq tipo [esq]:identificador dois_pontos [dir]:identificador par_dir comando_casado
 	|{atrib_ponto} atrib ponto
 	|{retorne} retorne exp? ponto
 	|{bloco} bloco
 	|{chamada} chamada ponto;
 
 p_var {-> a_var} = 
 	identificador {-> New a_var.identificador(identificador)}
 	|{var} p_var colchete_esq exp colchete_dir;
 
 exp =
 	{nivel_zero} exp prece_ou nivel_um |{nivel_um} nivel_um;
 
 //prefixo prece significa "precedência" e quanto maior o nível maior a precedência

 //nivel 0
 prece_ou = ou;
 
 prece_e = e;
 
 nivel_um = 
 	 {nivel_um} nivel_um prece_e nivel_dois 
 	|{nivel_dois} nivel_dois;
 
 prece_igual = igual;
 
 nivel_dois = 
 	 {nivel_dois} nivel_dois prece_igual nivel_tres 
 	|{nivel_tres} nivel_tres;
 
 prece_maior_menor_igual = 
 	 {menor_igual} menor_igual
 	|{maior_igual} maior_igual
 	|{menor} menor
 	|{maior} maior;
 
 nivel_tres = 
 	 {nivel_tres} nivel_tres prece_maior_menor_igual nivel_quatro 
 	|{nivel_quatro} nivel_quatro;
 
 prece_soma_menos = {soma} soma | {menos} menos;
 
 nivel_quatro = 
 	 {nivel_quatro} nivel_quatro prece_soma_menos nivel_cinco 
 	|{nivel_cinco} nivel_cinco;
 
 prece_mult_div = {mult} mult | {div} div;
 
 nivel_cinco = 
 	 {nivel_cinco} nivel_cinco prece_mult_div nivel_seis 
 	|{nivel_seis} nivel_seis;
 
 prece_nao = nao;
 
 nivel_seis = 
 	 {nivel_seis} prece_nao nivel_seis 
 	|{prece_par_valor} prece_par_valor;
 
 prece_par_valor = 
 	 {par_exp} par_esq exp par_dir
 	|{var} p_var
 	|{numero} numero 
 	|{caractere} caractere
 	|{string} string
 	|{booleano} booleano
 	|{chamada} chamada;
 
 chamada = identificador par_esq lista_exp par_dir;
 
 lista_exp = 
 	{nada}
 	|{exp} exp ou_exp_estrela*;
 	
 ou_exp_estrela = barra exp; 
 
 
 Abstract Syntax Tree
 
 a_programa = {ar_programa} a_dec_variavel* a_dec_funcao*;
 
 a_dec_variavel = {ar_declaracoes} a_tipo a_lista_nomes;
 
 a_lista_nomes = {identificadores} identificador a_lista_nomes
 				|{identificador} identificador;
 				
 a_tipo = {tipo_base} a_tipo_base
 		  |{vetor} vetor_palavra a_tipo_base a_vetor_estrela*;
 
 a_vetor_estrela = colchete_esq a_exp colchete_dir;
 		  
 a_tipo_base = 
 	 {booleano} booleano_palavra
	|{caractere} caractere_palavra
	|{numero} numero_palavra;
	
 a_dec_funcao = iniciador? a_tipo_retorno identificador a_parametros a_bloco;
 
 a_tipo_retorno = {tipo} a_tipo | {vazio} palavra_vazio;
 
 a_parametros = {nada}
 		|{varios_parametros} a_parametro a_parametro_estrela*;
 
 a_parametro = a_tipo identificador;
 
 a_parametro_estrela = barra a_parametro;
 				
 a_bloco = a_dec_variavel* a_comando*;
 
 a_atrib = a_var atribuicao a_exp;
 
 a_lista_atrib = a_atrib a_atrib_estrela*;

 a_atrib_estrela = virgula a_atrib;
 
 a_comando_casado  = 
 	 {se} a_exp [esq]:a_comando_casado [dir]:a_comando_casado
    |{outra} a_outra; 
    
 a_comando_nao_casado = 
 	 {se} a_exp a_comando
    |{se_senao} a_exp a_comando_casado a_comando_nao_casado;
       
 a_comando = {comando_casado} a_comando_casado
 			|{comando_nao_casado} a_comando_nao_casado;
 			
 a_outra = 
 	 {enquanto} enquanto par_esq a_exp par_dir a_comando_casado
 	|{para} para par_esq [atrib_esq]:a_lista_atrib [esq]:ponto_e_virgula a_exp [dir]:ponto_e_virgula [atrib_dir]:a_lista_atrib par_dir a_comando_casado
 	|{para_cada} para_cada par_esq a_tipo [esq]:identificador dois_pontos [dir]:identificador par_dir a_comando_casado
 	|{atrib_ponto} a_atrib ponto
 	|{retorne} retorne a_exp? ponto
 	|{bloco} a_bloco
 	|{chamada} a_chamada ponto;
 			
 a_var = {identificador} identificador
 		|{var} a_var a_exp;
 		
 a_exp = 
 	 {a_soma} [esq]:a_exp [dir]:a_exp
 	|{a_menos} [esq]:a_exp [dir]:a_exp
 	|{a_mult} [esq]:a_exp [dir]:a_exp
 	|{a_div} [esq]:a_exp [dir]:a_exp
 	|{a_igual} [esq]:a_exp [dir]:a_exp
 	|{a_menor} [esq]:a_exp [dir]:a_exp
 	|{a_maior} [esq]:a_exp [dir]:a_exp
 	|{a_menor_igual} [esq]:a_exp [dir]:a_exp
 	|{a_maior_igual} [esq]:a_exp [dir]:a_exp
 	|{a_e} [esq]:a_exp [dir]:a_exp
 	|{a_ou} [esq]:a_exp [dir]:a_exp
 	|{a_numero} numero
 	|{a_caractere} caractere
 	|{a_booleano} booleano
 	|{a_string} string;
 
 a_chamada = identificador a_lista_exp;
 
 a_lista_exp = {nada}
 	|{exp} a_exp a_ou_exp_estrela*;
 	
 a_ou_exp_estrela = barra a_exp; 
 
