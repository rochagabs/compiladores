Package caju;

Helpers
 digito = ['0' .. '9'];
 espaco = ' ';
 rc = 13;
 nl = 10;
 quebra_linha = [rc + nl];
 letra_minusc = ['a'..'z'];
 letra_maiusc = ['A'..'Z'];
 tudo = [0..0xffff];
 tudo_sem_nl = [tudo - quebra_linha];
 string_input = [tudo - ['''+'"']];
 identificadorhelper = (letra_maiusc | letra_minusc)(letra_maiusc | letra_minusc | digito | '_')*;
 comentario = [tudo - '{'];
 digitos = digito+;
 numero_real = '-'?digitos','digitos;
 numero_inteiro = '-'?digitos;
 
Tokens 
 numero = (numero_real | numero_inteiro);
 soma = '+';
 menos = '-';
 mult = '*';
 div = '/';
 igual = '=';
 maior = '>';
 menor = '<';
 maior_igual = '>=';
 menor_igual = '<=';
 inicio = 'inicio';
 fim = 'fim';
 booleanoid = 'booleano';
 numeroid = 'numero';
 caractereid = 'caractere';
 vetorid = 'vetor';
 palavra_vazio = 'vazio';
 string = '"'string_input*'"';
 par_esq = '(';
 par_dir = ')';
 colchete_esq = '[';
 colchete_dir = ']';
 ponto = '.';
 virgula = ',';
 barra = '|';
 ponto_e_virgula = ';';
 iniciador = '->';
 atribuicao = ':=';
 dois_pontos = ':';
 booleano = 'verdadeiro' | 'falso';
 enquanto = 'enquanto';
 para_cada = 'para cada';
 para = 'para';
 retorne = 'retorne';
 se = 'se';
 senao = 'senao';
 nao = 'nao';
 e = 'e';
 ou = 'ou';
 vazio = (espaco | rc | nl)+;
 caractere = '''(string_input | '\'letra_minusc)''';
 identificador = identificadorhelper;
 comentario_linha = '#'tudo_sem_nl*;
 comentario_bloco = '{'comentario*'}';

Ignored Tokens
 comentario_linha,
 comentario_bloco,
 vazio;

Productions

 programa = dec_variavel* dec_funcao*;

 dec_variavel = tipo_base lista_nomes ponto;
 
 lista_nomes = 
 	 {identificadores} identificador virgula lista_nomes
 	|{identificador} identificador;
 	
 tipo =
 	 {tipo_base} tipo_base
 	|{vetor} vetorid tipo_base colchete_esq exp colchete_dir vetor_estrela*;
 
 vetor_estrela = colchete_esq exp colchete_dir;
 
 tipo_base = 
 	 {booleanoid} booleanoid
	|{caractereid} caractereid
	|{numeroid} numeroid;
 
 dec_funcao =
 	 iniciador? tipo_retorno par_esq parametros par_dir bloco;
 	 
 tipo_retorno = {tipo} tipo | {vazio} palavra_vazio;
 
 parametros =
 	|{nada}
 	|{parametro} parametro parametro_estrela*;
 
 parametro = tipo identificador;
 
 parametro_estrela = barra parametro;
 
 bloco = inicio dec_variavel* comando* fim;
 
 atrib = var atribuicao exp;
 
 lista_atrib = atrib atrib_estrela*;

 atrib_estrela = virgula atrib;
 
 comando = 
 	 {se} se par_esq exp par_dir comando
 	|{senao} se par_esq exp par_dir senao comando
 	|{enquanto} enquanto par_esq exp par_dir comando
 	|{para} par_esq lista_atrib [esq]:ponto_e_virgula exp [dir]:ponto_e_virgula par_dir comando
 	|{para_cada} par_esq tipo identificador dois_pontos par_dir comando
 	|{atrib_ponto} atrib ponto
 	|{retorne} retorne exp? ponto
 	|{bloco} bloco
 	|{chamada} chamada ponto;
 
 var = 
 	 {identificador} identificador
 	|{var} var colchete_esq exp colchete_dir;
 
 exp =
 	 {numero} numero | {caractere} caractere | {booleano} booleano
 	|{var} var
 	|{par_exp} par_esq exp par_dir
 	|{chamada} chamada
 	|{soma} [esq]:exp soma [dir]:exp
 	|{menos} [esq]:exp menos [dir]:exp
 	|{mult} [esq]:exp mult [dir]:exp
 	|{div} [esq]:exp div [dir]:exp
 	|{igual} [esq]:exp igual [dir]:exp
 	|{menor_igual} [esq]:exp menor_igual [dir]:exp
 	|{maior_igual} [esq]:exp maior_igual [dir]:exp
 	|{menor} [esq]:exp soma [dir]:exp
 	|{maior} [esq]:exp soma [dir]:exp
 	|{nao} nao [dir]:exp
 	|{e} [esq]:exp e [dir]:exp
 	|{ou} [esq]:exp ou [dir]:exp;

 chamada = identificador par_esq lista_exp par_dir;
 
 lista_exp = 
 	|{nada}
 	|{exp} exp ou_exp_estrela;
 	
 ou_exp_estrela = barra exp; 
 
 